import convex_hull
from PIL import Image,ImageDraw
import random
import math
import time

class simpleTriangulation(object):
    triangles = []

    def __init__(self, draw):
        bc = BarycentricCoordinates()
        self.triangulateConvHull(draw)
        self.triangulateCloud(draw, bc)
        
    
    def triangulateConvHull(self, draw):
        ''' triangulate convex hull '''
        for i in range(1,len(cv.polygon)-1):
            draw.line([cv.polygon[0],cv.polygon[i]], fill="black")
            self.triangles.append([cv.polygon[0],cv.polygon[i],cv.polygon[i-1]])
        

    def triangulateCloud(self,draw, bc):
        ''' triangulate the point set except convex hull '''
        for i in range(len(c.cloud)):
            tri = self.isPointInTriangle(c.cloud[i], bc)
            if tri != False:
                draw.line([c.cloud[i],tri[0]], fill="black")
                draw.line([c.cloud[i],tri[1]], fill="black")
                draw.line([c.cloud[i],tri[2]], fill="black")
                self.triangles.append([c.cloud[i],tri[0],tri[1]])
                self.triangles.append([c.cloud[i],tri[1],tri[2]])
                self.triangles.append([c.cloud[i],tri[2],tri[0]])
                self.triangles.remove(tri)
                
                
    def isPointInTriangle(self, point, bc):
        ''' returns False if point is not inside anyone triangle'''
        ''' if not, returns the triangle that is inside '''
        flag = False
        i = 0
        while i<len(self.triangles):
            p1 = self.triangles[i][0]
            p2 = self.triangles[i][1]
            p3 = self.triangles[i][2]
    
            bar_c = bc.calcBarCoord(p1,p2,p3,point)
            
            if bar_c!=None:
                if bar_c[0] > 0.0 and bar_c[1] > 0.0 and bar_c[2] > 0.0:
                    ''' point is inside the triangle: self.triangles[i] '''
                    flag = True
                    tri = self.triangles[i]
                    i = len(self.triangles)
            i = i+1
            
        if flag == True:
            ''' return the coordinates of the triangle '''
            return tri
        else:
            ''' return false '''
            return flag


class BarycentricCoordinates():
    def calcBarCoord(self, p1, p2, p3, p):
        ''' calculate the barycentric coordinates '''
        p1x = float(p1[0])
        p1y = float(p1[1])
        p2x = float(p2[0])
        p2y = float(p2[1])
        p3x = float(p3[0])
        p3y = float(p3[1])
        px = float(p[0])
        py = float(p[1])

        d = (p2y - p3y)*(p1x - p3x) + (p3x - p2x)*(p1y - p3y)
        if d!=0:
            alpha = ((p2y - p3y)*(px - p3x) + (p3x - p2x)*(py - p3y)) / ((p2y - p3y)*(p1x - p3x) + (p3x - p2x)*(p1y - p3y))
            beta = ((p3y - p1y)*(px - p3x) + (p1x - p3x)*(py - p3y)) / ((p2y - p3y)*(p1x - p3x) + (p3x - p2x)*(p1y - p3y)) 
            gamma = 1 - alpha - beta
            return [alpha, beta, gamma]
        else:
            return None


class circleThroughThreePoints():
    def center(self,p1,p2,p3):
        ''' returns the coordinates of the center point of the circle defined by three points '''
        ''' return None if there is no circle '''
        c = None
        
        x1 = float(p1[0])
        y1 = float(p1[1])
        x2 = float(p2[0])
        y2 = float(p2[1])
        x3 = float(p3[0])
        y3 = float(p3[1])

        if x2!=x1 and x3!=x2 and y2!=y1 and y3!=y2:
            ma = (y2-y1)/(x2-x1)
            mb = (y3-y2)/(x3-x2)
            if ma!=mb and ma!=0:
                cx = (ma*mb*(y1-y3)+mb*(x1+x2)-ma*(x2+x3))/(2*(mb-ma))               
                cy = -(1/ma)*(cx-(x1+x2)/2)+(y1+y2)/2
                c = (cx,cy)

        elif x2==x1 or x2==x3:
            print 'vertical line'

        return c

            
    def radius(self, c, p):
        point = []
        center = []
        point.append(float(p[0]))
        point.append(float(p[1]))
        center.append(float(c[0]))
        center.append(float(c[1]))
        rad =  ((point[0]-center[0])**2+(point[1]-center[1])**2)
        
        return rad


    
class Delaunay(object):
    def __init__(self, draw, triangles, cloud, conv_h):
        cir = circleThroughThreePoints()
        self.deleteConvHullPoints(cloud, conv_h)
        self.checkTriangles(cloud, triangles, cir, draw)

    def checkTriangles(self, cloud, triangles, cir, draw):
        center_c = ()
        for j in range(len(triangles)):
            center = cir.center(triangles[j][0],triangles[j][1],triangles[j][2])
            if center!=None:
                rad_sqr = cir.radius(center, triangles[j][0])
                i=0
                while i < len(cloud):
                    x = cloud[i][0]
                    y = cloud[i][1]
                    
                    if ((x-center[0])**2+(y-center[1])**2)<rad_sqr:
                        ''' a point is inside the circle => triangle[j] is not Delaunay '''
                        draw.polygon(triangles[j], fill="yellow", outline='black')
                        i = len(cloud)
                    i=i+1  

    def deleteConvHullPoints(self, cloud, conv_h):
        ''' delete from set points the convex hull points '''
        for i in range(len(conv_h)):
            cloud.remove(conv_h[i])

            
                
if __name__=='__main__':
    
    im = Image.new("RGBA", (1000,800), (255,255,255,255))
    draw = ImageDraw.Draw(im)

    points = int(raw_input("How many points?"))
    
    c = convex_hull.Cloud(draw, points)
    cv = convex_hull.ConvHull(draw, c.cloud)
    st = simpleTriangulation(draw)
    
    dt = Delaunay(draw, st.triangles, c.cloud, cv.polygon)
    
    im.save("new.png")

    
